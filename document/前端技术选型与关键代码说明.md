# 前端技术选型与关键代码说明

## 一、选型背景

本系统为智慧物流车队与配送管理系统，主要功能包括车辆与司机管理、运单管理、异常管理以及统计报表展示。系统以数据库设计与业务规则实现为核心，前端主要承担数据展示、信息录入及基础交互功能。

在技术选型时，综合考虑了以下因素：

- 课程设计以数据库应用为重点；
- 系统规模适中，功能以管理类页面为主；
- 开发周期有限，需保证系统稳定性与可维护性；
- 项目成员前端开发经验有限，不宜引入复杂框架。

基于上述考虑，系统采用了以服务端渲染为主的前端技术方案。

## 二、前端总体技术方案

本系统前端采用 Flask + Jinja2 + Bootstrap 的技术组合，属于服务端模板渲染模式，不采用前后端分离架构。

整体特点如下：

- 页面由后端生成并直接返回浏览器；
- 前端不维护独立的状态管理逻辑；
- 通过 HTML 表单与后端进行数据交互；
- 样式与布局依赖成熟的 UI 框架。

## 三、前端技术组成

### 3.1 模板引擎：Jinja2

系统使用 Flask 内置的 Jinja2 模板引擎 作为前端页面生成工具。

主要作用：

- 将后端查询得到的数据动态渲染到 HTML 页面中；
- 实现页面模板复用，提高代码可维护性；
- 支持条件判断与循环渲染，适合列表与表格展示。

典型应用场景：

- 运单列表、异常列表、统计报表等页面的数据展示；
- 根据用户角色（主管 / 司机）控制页面元素显示；
- 复用基础布局模板。

### 3.2 页面布局与样式：Bootstrap

系统前端样式与布局采用 Bootstrap 5 框架实现。

选用原因：

- Bootstrap 提供完善的响应式布局体系；
- 内置大量常用组件，减少样式开发工作量；
- 学习成本低，适合课程项目快速开发。

在系统中的应用：

- 使用栅格系统实现页面布局；
- 使用表格组件展示运单、异常等结构化数据；
- 使用按钮、表单、徽章等组件提升页面可读性；
- 使用折叠、提示等组件实现基础交互效果。

### 3.3 前端交互方式

系统未采用复杂的前端交互框架，主要使用以下方式实现页面交互：

- HTML 表单（GET / POST）提交数据；
- URL 参数进行筛选与分页；
- 页面跳转方式查看详情或执行操作；
- 少量 Bootstrap 自带 JavaScript 实现折叠、提示等效果。

该方式实现简单、行为明确，便于调试和维护。

## 四、前端架构模式

系统前端采用 传统服务端渲染架构（MVC / MVT 模式），其流程如下：

1. 用户在浏览器发起请求；
2. Flask 后端接收请求并执行业务逻辑；
3. 后端从数据库中查询数据；
4. 使用 Jinja2 将数据渲染为 HTML 页面；
5. 将完整页面返回浏览器显示。

在该架构中，前端主要负责展示，核心业务逻辑与数据校验集中在后端与数据库层完成。

## 五、总结

综上所述，本系统前端采用 Flask + Jinja2 + Bootstrap 的服务端渲染技术方案，具有结构清晰、实现简单、维护成本低等优点。该方案能够有效支撑系统的运单管理、异常监控与统计展示功能，同时突出数据库设计与业务规则实现的核心地位，符合数据库课程设计的要求。

## 六、结合项目代码的关键案例（节选）

本节补充说明“服务端渲染 + Jinja2 + Bootstrap”在本系统中的落地方式，并给出关键代码案例。

### 6.1 模板继承与基础布局复用（Jinja2）

项目使用基础布局模板统一导航栏、侧边菜单与消息提示区，其它页面通过 `extends + block` 复用结构，仅实现页面主体内容。

示例 1：基础布局定义（文件：`templates/base.html`）

```html
<div class="container my-3">
  {% with messages = get_flashed_messages(with_categories=true) %}
    {% if messages %}
      {% for cat, msg in messages %}
        <div class="alert {% if cat=='success' %}alert-success{% else %}alert-danger{% endif %}">{{ msg }}</div>
      {% endfor %}
    {% endif %}
  {% endwith %}

  <div class="row">
    <div class="col-3">...侧边菜单...</div>
    <div class="col-9">
      {% block content %}{% endblock %}
    </div>
  </div>
</div>
```

示例 2：页面继承并填充内容区（文件：`templates/orders_list.html`）

```html
{% extends "base.html" %}
{% block content %}
  <h4 class="mb-0">运单管理</h4>
  <!-- 页面主体内容 -->
{% endblock %}
```

### 6.2 角色驱动的页面差异化展示（条件渲染）

本系统支持“主管/司机”两类角色。前端展示层通过 Jinja2 条件判断，控制菜单项与按钮的可见性，使页面与权限一致。

示例 1：侧边栏按角色展示不同菜单（文件：`templates/base.html`）

```html
{% if user and user.role == 'supervisor' %}
  <div class="mt-2 small text-muted">主管菜单</div>
  <a class="list-group-item list-group-item-action" href="{{ url_for('master_vehicles') }}">车辆管理</a>
  <a class="list-group-item list-group-item-action" href="{{ url_for('orders_list') }}">运单管理</a>
{% elif user and user.role == 'driver' %}
  <div class="mt-2 small text-muted">司机菜单</div>
  <a class="list-group-item list-group-item-action" href="{{ url_for('orders_list') }}">我的运单</a>
{% endif %}
```

示例 2：仅主管可见“新建运单”按钮（文件：`templates/orders_list.html`）

```html
{% if user.role == 'supervisor' %}
  <a class="btn btn-sm btn-primary" href="{{ url_for('orders_new') }}">新建订单</a>
{% endif %}
```

### 6.3 列表渲染与空值处理（循环渲染 + 表格）

管理类系统的核心页面通常是“列表 + 详情”。本项目使用 Bootstrap 表格组件结合 Jinja2 循环渲染，将数据库查询结果直接展示为可读的结构化页面。

示例：运单列表渲染（文件：`templates/orders_list.html`）

```html
<table class="table table-striped mt-2">
  <tbody>
    {% for o in orders %}
      <tr>
        <td>{{ o.order_id }}</td>
        <td>{{ o.destination }}</td>
        <td>{{ o.license_plate_number or '-' }}</td>
        <td>{{ o.driver_name or '-' }}</td>
        <td><a href="{{ url_for('order_detail', order_id=o.order_id) }}">详情</a></td>
      </tr>
    {% endfor %}
  </tbody>
</table>
```

### 6.4 以 GET 参数实现筛选（表单 -> request.args -> 渲染回填）

项目中“筛选/查询”采用 GET 表单提交，将条件编码到 URL 参数中，便于分享链接与复现查询；后端读取 `request.args` 组装查询条件后再渲染页面，并把筛选值回填到表单中。

示例 1：筛选表单使用 GET（文件：`templates/orders_list.html`）

```html
<form method="get" action="{{ url_for('orders_list') }}" class="card p-3 mb-3 mt-2">
  <select class="form-select" name="scope">
    <option value="all"  {% if scope == 'all' %}selected{% endif %}>所有订单</option>
    <option value="mine" {% if scope == 'mine' %}selected{% endif %}>我的订单</option>
  </select>
  <select class="form-select" name="assign">
    <option value="all" {% if assign == 'all' %}selected{% endif %}>全部</option>
    <option value="unassigned" {% if assign == 'unassigned' %}selected{% endif %}>待分配</option>
  </select>
  <button class="btn btn-primary" type="submit">筛选</button>
</form>
```

示例 2：后端读取 URL 参数并传回模板（文件：`app.py`）

```python
@app.get("/orders/list")
@login_required
def orders_list():
    user = current_user()
    scope = request.args.get("scope", "all")
    assign = request.args.get("assign", "all")

    # ...根据 scope/assign 组装 where_clauses 与 params...
    rows = db.fetch_all(sql, tuple(params))

    return render_template(
        "orders_list.html",
        user=user,
        orders=rows,
        scope=scope,
        assign=assign,
    )
```

同类实现还包括“近 7 天异常告警”页面的多条件筛选等。

### 6.5 以 POST 表单实现数据提交（服务端校验 + PRG）

本项目采用 HTML 表单 POST 提交数据；后端在接收请求后执行服务端校验与权限校验，并使用 `flash + redirect` 形成 PRG（Post/Redirect/Get）流程：

- 成功：提交后重定向到列表/详情页，避免刷新导致的重复提交；
- 失败：提示错误并重定向回表单页面。

示例 1：表单页面（文件：`templates/order_form.html`）

```html
<form method="post"
      action="{% if mode == 'edit' %}{{ url_for('order_edit_post', order_id=order.order_id) }}{% else %}{{ url_for('orders_create_post') }}{% endif %}">
  <input class="form-control" name="weight" type="number" min="0.01" step="0.01" required>
  <input class="form-control" name="volume" type="number" min="0.01" step="0.01" required>
  <input class="form-control" name="destination" required>
  <button class="btn btn-primary" type="submit">提交</button>
</form>
```

示例 2：后端接收 POST、校验并重定向（文件：`app.py`）

```python
@app.post("/orders/new")
@login_required
@role_required(ROLE_SUPERVISOR)
def orders_create_post():
    weight = float(request.form["weight"])
    volume = float(request.form["volume"])
    destination = request.form["destination"].strip()

    if weight <= 0:
        flash("货物重量必须大于 0。", "error")
        return redirect(url_for("orders_new"))

    db.execute(
        "INSERT INTO orders (weight, volume, destination, vehicle_id, driver_id, status) VALUES (%s, %s, %s, %s, %s, %s)",
        (weight, volume, destination, vehicle_id, driver_id, status),
    )
    flash("运单创建成功。", "success")
    return redirect(url_for("orders_list"))
```

### 6.6 统一消息提示（Flash + Bootstrap Alert）

为保证用户操作反馈一致性，项目将消息提示统一放在 `base.html` 中渲染；后端以 `flash(message, category)` 触发提示信息。

示例：后端触发消息提示（文件：`app.py`）

```python
flash("运单创建成功。", "success")
flash("非法的运单状态。", "error")
```

对应的模板渲染见 6.1 的 `get_flashed_messages()` 示例。

### 6.7 报表类页面：type=month 输入 + 结果渲染 + 模板运算

统计报表适合服务端渲染：后端调用存储过程得到统计结果，模板直接展示并进行少量格式化/运算（如百分比、保留小数）。

示例 1：月份输入（文件：`templates/report_fleet_monthly.html`）

```html
<input class="form-control" type="month" name="ym" value="{{ ym }}" required>
```

示例 2：模板运算与格式化（文件：`templates/report_fleet_monthly.html`）

```html
完成率：<b>{{ (report.completion_rate * 100) | round(2) }}%</b>
```

示例 3：后端读取参数并调用存储过程（文件：`app.py`）

```python
ym = request.args.get("ym", "").strip() or datetime.now().strftime("%Y-%m")
year, month = map(int, ym.split("-"))
row = db.call_proc_sp_fleet_monthly_report(user["fleet_id"], year, month)
return render_template("report_fleet_monthly.html", user=user, ym=ym, report=row)
```

### 6.8 访问控制：装饰器 + 会话（确保“页面展示”与“接口访问”一致）

为避免仅靠前端隐藏按钮造成越权，项目在后端路由层使用装饰器进行权限控制；模板侧边栏/按钮展示与后端权限保持一致。

示例：登录态与角色校验（文件：`auth.py`）

```python
def login_required(view):
    @wraps(view)
    def wrapper(*args, **kwargs):
        if "role" not in session:
            return redirect(url_for("login", next=request.path))
        return view(*args, **kwargs)
    return wrapper

def role_required(*roles):
    def deco(view):
        @wraps(view)
        def wrapper(*args, **kwargs):
            if session.get("role") not in roles:
                flash("无权限访问该页面。", "error")
                return redirect(url_for("dashboard"))
            return view(*args, **kwargs)
        return wrapper
    return deco
```

### 6.9 少量自定义样式（static 目录）

在 Bootstrap 的基础上，项目仅做了少量统一风格调整（背景色、卡片圆角等），以降低 CSS 维护成本。

示例 1：加载静态样式（文件：`templates/base.html`）

```html
<link href="{{ url_for('static', filename='app.css') }}" rel="stylesheet">
```

示例 2：自定义样式（文件：`static/app.css`）

```css
body { background: #f7f7f7; }
.card { border-radius: 10px; }
pre { margin: 0; }
```

### 6.10 登录页：下拉选择 + 会话写入（适用于课程演示）

考虑到课程演示与快速验收，本项目未引入独立的前端登录 SDK 或复杂认证流程，而是采用“服务端渲染 + 下拉选择角色与人员”的方式进入系统：

- 登录页由后端从数据库读取司机/主管列表并渲染为下拉选项；
- 提交后后端写入 `session`，前端菜单与路由权限随会话变化。

示例 1：登录页下拉渲染（文件：`templates/login.html`）

```html
<form method="post" action="{{ url_for('login_post') }}">
  <select class="form-select" name="role" required>
    <option value="supervisor">主管</option>
    <option value="driver">司机</option>
  </select>

  <select class="form-select" name="supervisor_id">
    {% for s in supervisors %}
      <option value="{{ s.supervisor_id }}">{{ s.supervisor_id }} - {{ s.name }}</option>
    {% endfor %}
  </select>

  <select class="form-select" name="driver_id">
    {% for d in drivers %}
      <option value="{{ d.driver_id }}">{{ d.driver_id }} - {{ d.name }}</option>
    {% endfor %}
  </select>
</form>
```

示例 2：后端渲染登录页与写入会话（文件：`app.py`）

```python
@app.get("/login")
def login():
    drivers = db.fetch_all("SELECT driver_id, name, fleet_id FROM drivers ORDER BY driver_id")
    supervisors = db.fetch_all("SELECT supervisor_id, name, fleet_id FROM supervisors ORDER BY supervisor_id")
    next_url = request.args.get("next") or url_for("dashboard")
    return render_template("login.html", drivers=drivers, supervisors=supervisors, next_url=next_url)

@app.post("/login")
def login_post():
    role = request.form.get("role")
    session.clear()
    session["role"] = role
    # ...按 role 写入 driver_id / supervisor_id / fleet_id 等信息...
    return redirect(request.form.get("next_url") or url_for("dashboard"))
```

### 6.11 校验案例：前端校验 + 后端校验（车牌号 / 电话号码）

在课程项目中，为提升用户体验并保证数据质量，本系统采用“前端校验 + 后端校验”的双层策略：

- 前端校验：尽早在浏览器侧拦截明显错误，减少无效提交；
- 后端校验：作为最终可信校验入口，防止绕过前端导致脏数据入库。

#### 6.11.1 前端校验：HTML5 约束（pattern / required / maxlength）

（1）司机电话：使用 `type="tel" + pattern + maxlength` 约束 11 位手机号格式。

示例（文件：`templates/master_driver_form.html`）

```html
<input class="form-control"
       name="phone"
       type="tel"
       inputmode="numeric"
       maxlength="11"
       pattern="^1\d{10}$"
       placeholder="13800000000"
       title="请输入 11 位手机号（1 开头，如 138xxxxxxxx）"
       required
       value="{{ driver.phone if driver else '' }}">
```

（2）车辆车牌号：使用 `pattern` 约束普通蓝牌格式（省份简称 + 字母 + 5 位字母数字）。

示例（文件：`templates/master_vehicle_form.html`）

```html
<input class="form-control"
       name="license_plate_number"
       maxlength="7"
       pattern="^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼][A-Z][A-Z0-9]{5}$"
       placeholder="沪A12345"
       title="示例：沪A12345（省份简称 + 字母 + 5 位）"
       style="text-transform:uppercase"
       required
       value="{{ vehicle.license_plate_number if vehicle else '' }}">
```

说明：前端校验属于“体验增强”，浏览器可被禁用/绕过，因此必须配合后端校验。

#### 6.11.2 后端校验：正则校验 + 统一规范化（strip/upper）

后端在 `app.py` 中实现了手机号与车牌号的正则校验函数，并在“新增/编辑司机、车辆”等写入入口统一调用：

示例 1：校验函数（文件：`app.py`）

```python
_PHONE_RE = re.compile(r"^1\d{10}$")
def validate_phone(phone: str) -> bool:
    phone = (phone or "").strip()
    return bool(_PHONE_RE.match(phone))

_PLATE_RE = re.compile(r"^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼][A-Z][A-Z0-9]{5}$")
def validate_plate_cn_blue(plate: str) -> bool:
    plate = (plate or "").strip().upper()
    return bool(_PLATE_RE.match(plate))
```

示例 2：新增车辆时的后端校验（文件：`app.py`，`master_vehicle_new_post()`）

```python
plate = request.form["license_plate_number"].strip().upper()
if not validate_plate_cn_blue(plate):
    flash("车牌号格式不合法（示例：沪A12345 / 粤B67890）。", "error")
    return redirect(url_for("master_vehicle_new"))
```

示例 3：新增司机时的后端校验（文件：`app.py`，`master_driver_new_post()`）

```python
phone = request.form["phone"].strip()
if not validate_phone(phone):
    flash("联系方式格式不合法，请输入 11 位手机号（如 138xxxxxxxx）。", "error")
    return redirect(url_for("master_driver_new"))
```

### 6.12 捕获触发器超载错误：数据库约束 -> 后端识别 -> 前端提示

“车辆超载”属于强业务约束：它依赖数据库中该车辆当前所有“活跃运单”的累计重量，且可能受并发操作影响，因此本系统将其放在数据库触发器中统一拦截；同时在后端捕获异常并转为用户可理解的提示信息。

示例 1：触发器抛出错误并回滚（文件：`sql/triggers.sql`，`trg_check_vehicle_capacity`）

```sql
IF EXISTS (
    SELECT 1
    FROM vehicles v
    JOIN (
        SELECT vehicle_id, SUM(weight) AS current_total_weight
        FROM orders
        WHERE status IN (N'待分配', N'运输中')
        GROUP BY vehicle_id
    ) o_sum ON v.vehicle_id = o_sum.vehicle_id
    WHERE o_sum.current_total_weight > v.max_weight
)
BEGIN
    RAISERROR (N'车辆超载！当前已分配货物重量超过车辆最大载重。', 16, 1);
    ROLLBACK TRANSACTION;
    RETURN;
END
```

示例 2：后端识别“触发器超载错误”（文件：`app.py`）

```python
def is_overload_trigger_error(e: Exception) -> bool:
    code, msg = mssql_error_code_and_message(e)
    return code == 50000 and ("车辆超载" in msg)
```

示例 3：在写入运单时捕获异常并给出友好提示（文件：`app.py`，`orders_create_post()`）

```python
try:
    db.execute(
        "INSERT INTO orders (weight, volume, destination, vehicle_id, driver_id, status) VALUES (%s, %s, %s, %s, %s, %s)",
        (weight, volume, destination, vehicle_id, driver_id, status),
    )
    flash("运单创建成功。", "success")
    return redirect(url_for("orders_list"))
except Exception as e:
    if is_overload_trigger_error(e):
        flash("分配失败：车辆超载（触发器校验）。", "error")
    else:
        code, msg = mssql_error_code_and_message(e)
        flash(f"分配失败：{msg or e}", "error")
    return redirect(url_for("orders_new"))
```

最终提示会在基础布局中以 Bootstrap 的 `alert` 组件呈现（见 `templates/base.html` 的 `get_flashed_messages()` 区块），实现“数据库强约束 + 前端可理解反馈”的闭环。
