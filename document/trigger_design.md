# 物流管理数据库触发器设计文档

本文档详细说明了物流管理系统中为保证数据完整性、自动化业务流程及审计需求而设计的三个核心触发器逻辑。

## 1. 自动载重校验 (Automatic Load Validation)

### 1.1 设计目标
防止因人为调度失误导致车辆超载，确保行车安全和合规性。系统应在每次分配或修改运单时，实时计算车辆的当前负载。

### 1.2 触发器名称
`trg_check_vehicle_capacity`

### 1.3 触发条件
*   **表**: `orders` (运单表)
*   **事件**: `AFTER INSERT`, `AFTER UPDATE`
*   **检测字段**: 仅当修改 `vehicle_id`（车辆变更）、`weight`（货物重量变更）或 `status`（运单状态变更）时触发。

### 1.4 实现逻辑
1.  **确定受影响车辆**: 从 `INSERTED` 表中获取涉及变更的 `vehicle_id`。
2.  **计算累计载重**:
    *   针对受影响的每一辆车，汇总其所有处于 **活跃状态**（`'待分配'`, `'运输中'`）的运单的 `weight` 总和。
    *   *注意*：状态为 `'已完成'` 或 `'异常'`（视具体业务而定，此处假设异常需人工介入暂不计入或另行处理，本设计暂只计算活跃载重）的运单不计入当前载重。
3.  **对比最大载重**: 将计算出的总重量与 `vehicles` 表中该车的 `max_weight` 进行对比。
4.  **执行校验**:
    *   如果 `当前总重 > 最大载重`，则认为超载。
    *   抛出错误信息 `RAISERROR`，并执行 `ROLLBACK TRANSACTION` 回滚本次操作，拒绝不合法的运单分配。

---

## 2. 车辆/运单状态自动流转 (Vehicle/Order Status Automation)

该功能由两个触发器协同完成，分别处理正常流程和异常流程的闭环。

### 2.1 运单开始流转
**触发器名称**: `trg_vehicle_status_auto_update` (Part 1)

*   **触发条件**: `orders` 表的 `UPDATE` 事件（当 `status` 从 `'待分配'` 变为 `'运输中'` 时）。
*   **设计逻辑**:
    1.  当运单被调度指派且开始执行时，识别该运单关联的车辆。
    2.  检查此车辆当前状态是否为 `'空闲'`。
    3.  如果是，则自动将车辆状态更新为 `'运输中'`。
    4.  这确保了车辆状态能即时反映业务活动，无需人工手动更新车辆状态。

### 2.2 运单完成流转
**触发器名称**: `trg_vehicle_status_auto_update` (Part 2)

*   **触发条件**: `orders` 表的 `UPDATE` 事件（当 `status` 变为 `'已完成'` 时）。
*   **设计逻辑**:
    1.  当运单状态更新为“已完成”时，识别该运单所属的车辆。
    2.  检查该车辆是否只剩当前已完成的运单，或者是否还有其他处于 `'待分配'`、`'运输中'` 或 `'异常'` 状态的运单。
    3.  如果该车辆没有任何其他活跃任务，则系统自动将该车辆的 `status` 更新为 `'空闲'`。
    4.  这减少了调度员手动释放车辆的操作，提高了车辆周转效率。

### 2.3 异常发生同步
**触发器名称**: `trg_exception_occurred_vehicle_status`

*   **触发条件**: `exception_events` 表的 `INSERT` 事件。
*   **设计逻辑**:
    1.  当新的异常事件被录入系统时。
    2.  自动将该异常关联的运单 (`orders`) 状态更新为 `'异常'`。
    3.  自动将该运单所使用的车辆 (`vehicles`) 状态更新为 `'异常'`。
    4.  这保证了在异常发生的第一时间，系统全链路状态的一致性，防止对异常车辆进行错误调度。

### 2.4 异常处理恢复

**触发器名称**: `trg_exception_handled_vehicle_status`

*   **触发条件**: `exception_events` 表的 `UPDATE` 事件（当 `status` 变为 `'已处理'` 时）。
*   **设计逻辑**:
    1.  当异常事件被标记为已处理时，获取关联的 `vehicle_id` 和 `exception_type`。
    2.  **更新运单状态**：不论是何种异常，只要关联的运单当前处于 `'异常'` 状态，都将其自动恢复为 `'运输中'`。
    3.  根据异常类型决定车辆恢复后的状态：
        *   **运输时异常**：通常意味着车辆在运输途中发生故障或事故，处理完毕后（如修好或事故处理完），车辆仍需继续完成运输任务（或返回），因此将状态恢复为 `'运输中'`。
        *   **空闲时异常**：车辆在停车场发现的故障，处理完毕后，车辆恢复为可用状态，即 `'空闲'`。
    4.  更新 `vehicles` 表对应车辆的状态。

---

## 3. 审计日志 (Audit Logging)

为了追踪关键数据的变更历史，设计了通用的审计机制，将变更前的旧数据以 JSON 格式存储。

### 3.1 司机关键信息审计
**触发器名称**: `trg_audit_log_drivers`

*   **触发条件**: `drivers` 表的 `UPDATE` 事件。
*   **监控字段**: `license_level` (驾照等级), `name`, `phone`。
*   **设计逻辑**:
    1.  检测是否发生了关键字段的变更。
    2.  如果是，提取 `DELETED` 表中的旧数据行。
    3.  使用 `FOR JSON PATH` 将旧数据行序列化为 JSON 字符串。
    4.  向 `history_log` 表插入一条记录：
        *   `table_name`: 'drivers'
        *   `operation_type`: 'UPDATE_KEY_INFO'
        *   `old_data`: 序列化后的 JSON 数据
        *   `change_id`: 被修改司机的 ID

### 3.2 异常事件归档
**触发器名称**: `trg_audit_log_exceptions`

*   **触发条件**: `exception_events` 表的 `UPDATE` 事件。
*   **监控行为**: 当 `status` 从非 `'已处理'` 变为 `'已处理'` 时。
*   **设计逻辑**:
    1.  捕捉异常处理的瞬间。
    2.  将处理前的异常记录（包含当时的罚款金额、描述、未处理状态等）保留在日志中。
    3.  向 `history_log` 表插入记录，`operation_type` 标记为 `'EXCEPTION_PROCESSED'`。
    4.  这提供了对事故处理全过程的可追溯性，便于后续的责任认定和查询。
