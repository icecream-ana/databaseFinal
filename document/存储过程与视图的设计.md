# 存储过程与视图的设计（FleetDB 物流管理系统）

> 本文档基于项目实际实现的 `procedures.sql` 与 `views.sql` 编写，说明每个存储过程/视图的**功能目标**、**输入输出**与**设计逻辑**。写作结构参考了你提供的触发器设计文档（强调“触发/使用场景 + 设计逻辑步骤 + 业务意义”）。

---

## 1. 设计目标

在 FleetDB 物流管理系统中，存储过程（Stored Procedure）与视图（View）主要用于：

1. **封装高频业务查询**：将复杂统计/联查逻辑固化在数据库层，减少应用层重复拼装 SQL。
2. **统一口径**：对“月报统计”“异常预警”等指标提供统一的计算方式，避免不同页面/模块口径不一致。
3. **提升可维护性**：复杂查询通过过程/视图集中管理，后续扩展维度（例如增加新统计字段）不影响调用端。
4. **便于性能优化**：过程/视图的访问路径更固定，更容易针对性设计索引（见《索引的设置策略.md》）。

---

## 2. 存储过程设计（procedures.sql）

### 2.1 车队月度运营报表：`dbo.sp_fleet_monthly_report`

**存储过程名称**：`dbo.sp_fleet_monthly_report`

**用途**：按“车队 + 年月”输出该车队在指定月份内的运营统计指标，包括：
- 运单总数、异常总数、罚款总额（核心三项）
- 运单状态结构与完成率/异常率
- 货量规模（重量/体积的总量、均值、极值）
- 车辆利用（活跃车辆数、空闲车辆数、单车运单数）
- 司机参与度（活跃司机数、人均运单）
- 异常处理压力（待处理异常数、单次异常平均罚款）

**输入参数**：
- `@fleet_id INT`：车队 ID
- `@year INT`：年份
- `@month INT`：月份（1-12）

**输出结果集**：
- 单行报表结果（列较多，覆盖上述指标）。

**设计逻辑**（按实际 SQL 的计算步骤拆解）：
1. **确定统计时间窗**：
   - `@start = DATETIMEFROMPARTS(@year, @month, 1, 0, 0, 0, 0)`
   - `@end = DATEADD(MONTH, 1, @start)`
   - 采用“左闭右开” `[start, end)`，避免跨月边界重复计入。
2. **构造当月车队运单集合（核心口径）**：CTE `fleet_orders`
   - 从 `orders o` 联结 `vehicles v`，限定 `v.fleet_id = @fleet_id`
   - 同时限定 `o.created_at` 在 `[start, end)`
   - 得到本月“该车队产生的运单全集”（后续所有指标均基于它计算，保证口径一致）。
3. **构造当月相关异常事件集合**：CTE `fleet_exceptions`
   - 从 `exception_events e` 与 `fleet_orders fo` 按 `order_id` 关联
   - 同样限定 `occurred_time` 在 `[start, end)`
   - 用于统计异常总数、罚款总额、待处理异常等。
4. **构造车队车辆全集（用于空闲车辆计算）**：CTE `fleet_vehicles`
   - 从 `vehicles` 直接筛选 `fleet_id`
5. **输出统计列（SELECT 聚合输出）**：
   - **A. 基础指标**：
     - `total_orders = COUNT(*)`（fleet_orders 行数）
     - `total_exceptions = (SELECT COUNT(*) FROM fleet_exceptions)`
     - `total_fines = SUM(fine_amount)`（异常罚款求和，空值用 0）
   - **B. 运单状态结构与比率**：
     - 对 `fo.status` 用 `SUM(CASE WHEN ... THEN 1 END)` 分桶
     - `completion_rate = 已完成 / 总运单`
     - `abnormal_order_rate = 异常运单 / 总运单`
     - `abnormal_event_rate = 异常事件数 / 总运单`（补充口径，区别“异常运单数”与“异常事件数”）
   - **C. 货量规模**：总量/均值/最大最小（weight/volume）
   - **D. 车辆利用**：
     - `active_vehicles = COUNT(DISTINCT vehicle_id)`（当月有运单的车辆）
     - `orders_per_active_vehicle = 总运单 / 活跃车辆数`
     - `idle_vehicles = 车队车辆中，不存在当月运单的车辆数`
   - **E. 司机绩效（车队维度）**：
     - `active_drivers = COUNT(DISTINCT driver_id)`
     - `orders_per_active_driver = 总运单 / 活跃司机`
   - **F. 异常压力与成本**：
     - `pending_exceptions`：异常状态为“待处理”的数量
     - `avg_fine_per_exception`：异常罚款均值

**设计意义**：
- 该过程把“月报的统计口径”固定下来，调用端只需提供车队与年月即可获得完整报表。
- 使用 CTE 分层构造数据集，使逻辑可读、可维护，并便于针对 `created_at / occurred_time / fleet_id` 等关键字段做索引优化。

---

### 2.2 司机绩效统计：`dbo.sp_driver_performance`

**存储过程名称**：`dbo.sp_driver_performance`

**用途**：统计某司机在指定时间段内：
1) 运单数量（总单量）；
2) 与这些运单相关的异常事件明细（异常 + 运单 + 车辆信息）。

**输入参数**：
- `@driver_id INT`：司机 ID
- `@start DATETIME`：起始时间（含）
- `@end DATETIME`：结束时间（不含，左闭右开）

**输出结果集**（注意：该过程返回 **两个** Result Set）：
1. **结果集 1（汇总）**：`driver_id, total_orders`
2. **结果集 2（明细列表）**：异常事件明细（按发生时间倒序）

**设计逻辑**：
1. **汇总统计（运单数）**：
   - 从 `orders` 筛选 `driver_id = @driver_id` 且 `created_at` 在 `[start, end)`
   - `COUNT(*)` 得到 `total_orders`
2. **异常明细联查**：
   - `orders o` → `vehicles v`（按 `vehicle_id`）
   - `orders o` → `exception_events e`（按 `order_id`）
   - 筛选条件同样以 `o.driver_id` 与 `o.created_at` 时间窗为准
   - 输出：异常事件信息（类型、状态、罚款、描述、发生时间）+ 运单信息（目的地、状态、创建时间）+ 车辆信息（车牌）
   - `ORDER BY e.occurred_time DESC`：便于管理端优先查看最新异常

**设计意义**：
- 把“司机 KPI 统计”与“异常追踪”合并在一个过程内，既能用于报表（总单量），也能用于定位问题（异常明细）。
- 以 `driver_id + created_at` 为核心过滤条件，能直接被复合索引加速（见索引策略）。

---

## 3. 视图设计（views.sql）

### 3.1 近 7 天异常告警联查视图：`dbo.vw_weekly_exception_alert`

**视图名称**：`dbo.vw_weekly_exception_alert`

**用途**：提供“近 7 天异常告警”的一张联查视图，将异常事件与组织层级信息一次性关联出来，用于管理端的告警列表/异常看板。

**核心输出字段**：
- 异常维度：`event_id, occurred_time, exception_type, exception_status, fine_amount, description`
- 运单维度：`order_id, created_at, destination, order_status`
- 司机维度：`driver_id, driver_name, driver_phone, license_level`
- 车辆维度：`vehicle_id, license_plate_number, vehicle_status`
- 组织维度：`fleet_id, fleet_name, center_id, center_name`

**联查链路（按实际 JOIN 关系）**：
1. `exception_events e` JOIN `orders o`（异常 → 运单）
2. `orders o` JOIN `drivers d`（运单 → 司机）
3. `orders o` JOIN `vehicles v`（运单 → 车辆）
4. `vehicles v` JOIN `fleets f`（车辆 → 车队）
5. `fleets f` JOIN `centers c`（车队 → 配送中心）

**过滤条件（近 7 天）**：
- `e.occurred_time >= DATEADD(DAY, -7, CAST(GETDATE() AS DATE))`

**设计意义**：
- 视图提供统一字段集合，前端/报表无需重复编写多表 JOIN。
- 时间过滤以 `occurred_time` 为主，配合 `IX_exception_events_occurred_time` 可显著减少扫描范围。

---

### 3.2 异常司机/车辆预警视图：`dbo.vw_abnormal_driver_vehicle_alert`

**视图名称**：`dbo.vw_abnormal_driver_vehicle_alert`

**用途**：对“高风险司机-车辆组合”进行预警，规则为：
- 近 30 天异常次数 `>= 3`（按 driver_id + vehicle_id 组合统计）
  **或**
- 车辆当前状态为 `异常`

**实现结构**（按实际 SQL 的 CTE 层级拆解）：
1. CTE `e30`：统计窗口内（近 30 天）异常事件
   - 从 `orders o` LEFT JOIN `exception_events e`
   - `e.occurred_time >= DATEADD(DAY, -30, GETDATE())`
   - 产出 driver_id、vehicle_id 维度上的异常事件集合
2. CTE `pair_stat`：按“司机-车辆组合”聚合
   - `GROUP BY driver_id, vehicle_id`
   - 得到 `exception_count`、`total_fines`
3. 主查询：补全维度信息并生成预警原因
   - 关联 `drivers / vehicles / fleets / centers`
   - 使用 `CASE` 输出 `warning_reason`：
     - 异常次数过多：`exception_count >= 3`
     - 车辆状态异常：`vehicle_status = '异常'`

**输出字段（关键列）**：
- 司机信息、车辆信息
- `exception_count_30d`：30 天异常次数
- `total_fines_30d`：30 天罚款总额
- `warning_reason`：预警原因说明

**设计意义**：
- 将“异常频发的司机-车辆组合”提前暴露给调度/管理端，用于风险控制（例如减少派单或触发安全检查）。
- 同时覆盖“历史异常频发”和“车辆当前异常状态”两类风险来源。

---

## 4. 过程/视图的典型调用方式

- 车队月报：
  - `EXEC dbo.sp_fleet_monthly_report @fleet_id=1, @year=2025, @month=12;`
- 司机绩效：
  - `EXEC dbo.sp_driver_performance @driver_id=10, @start='2025-12-01', @end='2026-01-01';`
- 近 7 天异常告警：
  - `SELECT * FROM dbo.vw_weekly_exception_alert ORDER BY occurred_time DESC;`
- 异常司机/车辆预警：
  - `SELECT * FROM dbo.vw_abnormal_driver_vehicle_alert ORDER BY exception_count_30d DESC;`

