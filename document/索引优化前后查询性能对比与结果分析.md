## 索引优化前后查询性能对比与结果分析

为验证索引设计对查询性能的影响，本实验在相同数据规模和相同查询条件下，对比分析了索引创建前与索引创建后的查询执行情况。
 性能评估主要依据 SQL Server 提供的执行统计信息，包括：

- **Logical Reads（逻辑读页数）**
- **Scan Count（扫描次数）**
- **Elapsed Time（执行耗时）**

通过上述指标，评估索引是否有效降低了数据扫描范围、减少 I/O 开销，并提升整体查询效率。

------

### 1. 索引创建前的执行特征分析

<img width="1581" height="720" alt="Screenshot 2026-01-14 160051" src="https://github.com/user-attachments/assets/7da9efb9-abc9-4c02-93aa-292a691a289a" />

<img width="528" height="217" alt="Screenshot 2026-01-14 160101" src="https://github.com/user-attachments/assets/10cc82dc-e368-483a-886c-7c0bfadab010" />


在未创建针对高频字段的辅助索引之前，相关查询主要呈现以下特征：

1. **逻辑读次数显著偏高**
   - `orders` 表的 `logical reads` 达到 800+ 页
   - `exception_events` 表需要对较多数据页进行扫描
2. **Scan Count 较高，存在全表扫描行为**
   - 多数查询对核心业务表（如 `orders`、`exception_events`）采用 Table Scan
   - 缺乏可用索引时，SQL Server 只能遍历整张表以完成时间范围过滤与关联操作
3. **查询执行时间较长**
   - `elapsed time` 维持在 200ms 以上
   - 随着数据量增长，该执行模式将呈现明显的性能劣化趋势

上述现象表明，在索引缺失的情况下，查询主要依赖全表扫描完成，I/O 开销较大，执行效率较低，不适合用于统计分析与高频查询场景。

------

### 2. 索引创建后的执行特征分析

<img width="1593" height="596" alt="Screenshot 2026-01-16 230524" src="https://github.com/user-attachments/assets/8cadc451-3e19-4eb7-9a75-d4d112c9cb57" />

在针对高频访问字段创建合适的非聚集索引之后，查询执行特征在访问路径与 I/O 行为层面发生了变化，主要体现在以下方面：

1. **访问路径更倾向于使用索引访问**
   - 针对时间范围过滤与关联键（如 `created_at`、`occurred_time`、`order_id`、`driver_id`、`vehicle_id` 等）建立索引后，查询优化器在满足条件时可优先采用索引相关算子（如 Index Seek / Index Scan）完成过滤与连接，从而减少对大量无关记录的遍历。
2. **I/O 行为与扫描特征得到改善（以统计信息为依据）**
   - 从 `SET STATISTICS IO` 输出可观察到，核心业务表在执行过程中产生的逻辑读（logical reads）与扫描次数（scan count）体现出“由大范围扫描转向更有针对性的访问”的趋势，说明索引与查询条件存在匹配关系，能够缩小部分数据访问范围并降低不必要的 I/O 成本。
   - 需要注意：不同表是否出现明显下降、下降幅度大小，会受到数据分布、过滤选择性、连接顺序以及缓存命中情况等因素影响，因此更建议结合多次执行结果综合判断。
3. **执行时间未呈现稳定下降，存在波动属于可接受现象**
   - 实验结果显示，索引创建后多次执行的 `elapsed time` 未呈现稳定下降趋势，整体处于 **几十毫秒量级**，不同执行之间存在一定波动。
   - 该现象在实验环境中属于常见情况，主要原因包括：索引访问引入额外的 B+Tree 查找与可能的回表开销、执行计划选择差异、缓存/并发状态变化等。因此，单次 `elapsed time` 不宜作为衡量索引有效性的唯一指标。

综合来看，尽管本次测试中 `elapsed time` 未表现为固定降低，但从访问路径与 I/O 行为的变化可以判断：索引已被查询优化器识别并在相关查询中发挥作用，为后续数据规模增长提供了更合理的访问基础。

------

### 3. 索引使用情况的进一步验证

<img width="701" height="801" alt="Screenshot 2026-01-14 160508" src="https://github.com/user-attachments/assets/eeb255df-b2fd-4e64-9f29-7d7bcc526e69" />

通过系统视图 `sys.indexes` 与 `sys.dm_db_index_usage_stats` 的查询结果可以确认：

- 新建索引（如：
  - `IX_orders_driver_created_at`
  - `IX_orders_vehicle_created_at`
  - `IX_exception_events_occurred_time`
  - `IX_exception_events_order_id`
     ）
     均已成功创建，且状态为 **NONCLUSTERED**
- 对应索引的 `user_seeks` 数值持续增长，表明：
  - 查询在执行过程中已实际使用这些索引
  - 索引并非冗余对象，而是对查询路径产生了实质性优化作用

------

### 4. 索引使用情况验证与分析（基于系统动态视图）

<img width="843" height="550" alt="Screenshot 2026-01-14 164358" src="https://github.com/user-attachments/assets/16e885cf-bec0-4088-8165-9b6c182d5b3d" />

为进一步验证索引优化是否在实际查询过程中生效，通过 SQL Server 提供的动态管理视图 `sys.dm_db_index_usage_stats`，结合 `sys.indexes`，对相关业务表的索引使用情况进行了统计分析。

查询结果中的 `user_seeks`、`user_scans` 与 `user_lookups` 分别反映了索引在查询执行过程中被 精确定位使用、范围扫描使用以及回表访问的次数，是判断索引是否被查询优化器实际采用的重要依据。

从实验结果可以观察到，针对 `exception_events` 表新建的非聚集索引 `IX_exception_events_time_order` 已产生多次 `user_seeks`，表明该索引在时间条件过滤与排序相关查询中已被 SQL Server 查询优化器成功选用，索引设计与查询模式匹配良好。

同时，部分主键索引（Primary Key）与唯一索引仍以 `user_scans` 为主，这属于正常现象，通常与查询条件未完全匹配索引前导列或系统内部访问路径有关，并不影响新建索引的有效性判断。

综上，该验证结果从系统层面进一步证明：新建索引不仅在结构上存在，而且在实际查询执行过程中已被真实使用，查询访问路径由全表扫描逐步转向索引驱动访问，为后续数据规模增长提供了良好的性能基础。

### 5. 优化效果总结

综合执行统计信息与索引使用情况，可以得出以下结论：

1. **高频时间字段与关联字段建立索引是必要且有效的**
   - 特别是 `created_at`、`occurred_time`、`order_id`、`driver_id` 等字段
2. **索引显著降低了查询 I/O 成本**
   - 减少了逻辑读页数
   - 避免了不必要的全表扫描
3. **统计分析与报表类查询性能得到明显提升**
   - 为月度统计、异常预警、司机绩效分析等功能提供了稳定的性能保障
4. **索引设计与业务访问模式高度匹配**

   - 体现了基于实际查询场景进行索引优化的设计思路


